//>>>>>>>>>>>>>>>>>>>>>>>>
//      TOP RULES
//<<<<<<<<<<<<<<<<<<<<<<<<
gnc = {
    SOI
    ~ (function | global_variable)*
    ~EOI
}

//>>>>>>>>>>>>>>>>>>>>>>
//  GLOBAL VARIABLES
//<<<<<<<<<<<<<<<<<<<<<<
global_variable = { declaration_statement ~ ";" }

//>>>>>>>>>>>>>>>>>>>
//      FUNCTIONS
//<<<<<<<<<<<<<<<<<<<
function = { data_type ~ identifier ~ function_parameter_list ~ "{" ~ statement* ~ "}" }
function_parameter_list = { "(" ~ function_parameter* ~ ")" }
function_parameter = { data_type ~ identifier }


//>>>>>>>>>>>>>>>>>>>>>>>>
//      STATEMENTS
//<<<<<<<<<<<<<<<<<<<<<<<<


// all the statements
block_statement = { "{" ~ statement* ~ "}" }

statement = {
    continue_statement |
    break_statement |
    declaration_statement ~ ";" |
    return_statement ~ ";" |
    expression? ~ ";" | // assignment
    if_statement |
    while_statement |
    do_while_statement ~ ";" |
    for_statement |
    block_statement
}


// declaration statement
declaration_statement = {
    data_type ~ ( declaration ~  ",")*  ~ declaration   // declaration
}

// assignment_statement = { identifier ~ "=" ~ expression ~ ( "," ~ identifier ~ "=" ~ expression )* }
return_statement = { "return" ~ expression? }
if_statement = { "if" ~ "(" ~ expression ~ ")" ~ statement ~ ("else" ~ statement)? }
while_statement = { "while" ~ "(" ~ expression? ~ ")" ~ statement }
for_statement = { "for" ~ "("
    ~ (declaration_statement | expression | none_for_condition)
    ~ ";" ~ (expression | none_for_condition) ~ ";"
    ~ (expression | none_for_condition) ~ ")" ~ statement
}
do_while_statement = { "do" ~ statement ~ "while" ~ "(" ~ expression? ~ ")" }
continue_statement = { "continue" }
break_statement = { "break" }


//>>>>>>>>>>>>>>>>>>>>>
//      EXPRESSIONS
//<<<<<<<<<<<<<<<<<<<<<
declaration = { identifier ~ ( "=" ~ expression ) ? }

// this non_for_condition is for parsing process
// Since I cannot get the number of all clauses in for-loop's condition,
// i have to mark the empty clause as non_for_condition
none_for_condition = { "" }

// expression
expression = {assignment_expression | logical_or_expression }

unary_expression = {
    "(" ~ expression ~ ")" |
    int_literal |
    identifier |
    op_arithmetic_not ~ unary_expression |
    op_logical_not ~ unary_expression |
    op_bitwise_not ~ unary_expression
}
multiplicative_expression = { unary_expression ~ ((op_mul | op_div | op_add) ~ unary_expression)* }
additive_expression = { multiplicative_expression ~ ((op_add | op_sub) ~ multiplicative_expression)* }
shift_expression = { additive_expression ~ ((op_shift_right | op_shift_left) ~ additive_expression)* }
comparison_expression = { shift_expression ~ ((op_ge | op_le | op_gt | op_lt)  ~ shift_expression)* }
equality_expression = { comparison_expression ~ ((op_ne | op_eq) ~ comparison_expression)* }
bitwise_and_expression = { equality_expression ~ (op_bitwise_and ~ equality_expression )* }
exclusive_or_expression = { bitwise_and_expression ~ (op_exclusive_or ~ bitwise_and_expression)* }
inclusive_or_expression = { exclusive_or_expression ~ (op_inclusive_or ~ exclusive_or_expression)* }
logical_and_expression = { inclusive_or_expression ~ (op_logical_and ~ inclusive_or_expression)* }
logical_or_expression = { logical_and_expression ~ (op_logical_or ~ logical_and_expression)* }

assignment_expression = { identifier ~ (assign_simple | assign_div | assign_mul | assign_mod |
    assign_add | assign_sub | assign_shift_left | assign_shift_right | assign_bitwise_and |
    assign_exclusive_or | assign_inclusive_or) ~ expression
}


//>>>>>>>>>>>>>>>
//   TOKENS
//<<<<<<<<<<<<<<<

// All these rules with a single symbol is needed and cannot be deleted
// Pest will strip all the internal strings and iteration will not include
// all strings.

// unary_operation
op_arithmetic_not = { "-" }
op_logical_not = { "!" }
op_bitwise_not = { "~" }

// binary operation
op_add = { "+" }
op_sub = { "-" }
op_mul = { "*" }
op_div = { "/" }
op_mod = { "%" }
op_shift_left = { "<<" }
op_shift_right = { ">>" }
op_ge = { ">=" }
op_le = { "<=" }
op_lt = { "<" }
op_gt = { ">" }
op_eq = { "==" }
op_ne = { "!=" }
op_bitwise_and = { "&" }
op_exclusive_or = { "^" }
op_inclusive_or = { "|" }
op_logical_and = { "&&" }
op_logical_or = { "||" }



assign_simple = { "=" }
assign_div = { "/=" }
assign_mul = { "*=" }
assign_mod = { "%=" }
assign_add = { "+=" }
assign_sub = { "-=" }
assign_shift_left = { "<<=" }
assign_shift_right = { ">>=" }
assign_bitwise_and = { "&=" }
assign_exclusive_or = { "^=" }
assign_inclusive_or = { "|=" }



identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

data_type = { "int" }


// literal
int_literal = { dec_literal | hex_literal | oct_literal }
dec_literal = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
hex_literal = @{ ^"0x" ~ ASCII_ALPHANUMERIC+ }
oct_literal = @{ "0" ~ ASCII_ALPHANUMERIC+ }

WHITESPACE = _{ " " | "\n" | "\r" }
COMMENT = _{
    ("/*" ~ (!"*/" ~ ANY)* ~ "*/") // Block comment
    | ("//" ~ (!"\n" ~ ANY)* ~ "\n") // Line comment
}




