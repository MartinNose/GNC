//>>>>>>>>>>>>>>>>>>>>>>>>
//      TOP RULES
//<<<<<<<<<<<<<<<<<<<<<<<<
gnc = {
    SOI
    ~ (function | global_variable)*
    ~EOI
}

//>>>>>>>>>>>>>>>>>>>>>>
//  GLOBAL VARIABLES
//<<<<<<<<<<<<<<<<<<<<<<
global_variable = { declaration_statement ~ ";" }

//>>>>>>>>>>>>>>>>>>>
//      FUNCTIONS
//<<<<<<<<<<<<<<<<<<<
function = { data_type ~ identifier ~ function_parameter_list ~ block_statement }
function_parameter_list = { "(" ~ function_parameter* ~ ")" }
function_parameter = { data_type ~ identifier }


//>>>>>>>>>>>>>>>>>>>>>>>>
//      STATEMENTS
//<<<<<<<<<<<<<<<<<<<<<<<<


// all the statements
block_statement = { "{" ~ statement* ~ "}" }

statement = {
    declaration_statement ~ ";" |
    assign_statement ~ ";" | // assignment
    if_statement |
    while_statement |
    do_while_statement ~ ";" |
    for_statement |
    return_statement ~ ";" |
    block_statement
}


// declaration statement
declaration_statement = {
    data_type ~ ( declaration ~  ",")*  ~ declaration   // declaration
}

assign_statement = { identifier ~ "=" ~ expression ~ ( "," ~ identifier ~ "=" ~ expression )* }
return_statement = { "return" ~ expression }
if_statement = { "if" ~ "(" ~ expression ~ ")" ~ statement ~ ("else" ~ statement)? }
while_statement = { "while" ~ "(" ~ expression? ~ ")" }
for_statement = { "for" ~ "(" ~ for_condition ~ ")" ~ statement }
do_while_statement = { "do" ~ statement ~ "while" ~ "(" ~ expression? ~ ")" }


//>>>>>>>>>>>>>>>>>>>>>
//      EXPRESSIONS
//<<<<<<<<<<<<<<<<<<<<<

for_condition = { declaration_statement? ~ ";" ~ expression? ~ ";" ~ assign_statement? }
declaration = { identifier ~ ( "=" ~ expression ) ? }

// expression
expression = { logical_or_expression }


unary_expression = {
    "(" ~ expression ~ ")" |
    int_literal |
    identifier |
    "-" ~ unary_expression |
    "!" ~ unary_expression |
    "~" ~ unary_expression
}
multiplicative_expression = { unary_expression ~ (("*" | "/") ~ unary_expression)* }
additive_expression = { multiplicative_expression ~ (("+" | "-") ~ multiplicative_expression)* }
shift_expression = { additive_expression ~ (("<<" | ">>") ~ additive_expression)* }
comparison_expression = { shift_expression ~ (("<=" | ">=" | "<" | ">") ~ shift_expression)* }
equality_expression = { comparison_expression ~ (("==" | "!=") ~ comparison_expression)* }
bitwise_and_expression = { equality_expression ~ ("&" ~ equality_expression )* }
exclusive_or_expression = { bitwise_and_expression ~ ("^" ~ bitwise_and_expression)* }
inclusive_or_expression = { exclusive_or_expression ~ ("|" ~ exclusive_or_expression)* }
logical_and_expression = { inclusive_or_expression ~ ("&&" ~ inclusive_or_expression)* }
logical_or_expression = { logical_and_expression ~ ("||" ~ logical_and_expression)* }



//>>>>>>>>>>>>>>>
//   TOKENS
//<<<<<<<<<<<<<<<

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

data_type = { "int" }


// literal
int_literal = { dec_literal | hex_literal | oct_literal }
dec_literal = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
hex_literal = @{ ^"0x" ~ ASCII_ALPHANUMERIC+ }
oct_literal = @{ "0" ~ ASCII_ALPHANUMERIC+ }

WHITESPACE = _{ " " | "\n" | "\r" }
COMMENT = _{
    ("/*" ~ (!"*/" ~ ANY)* ~ "*/") // Block comment
    | ("//" ~ (!"\n" ~ ANY)* ~ "\n") // Line comment
}