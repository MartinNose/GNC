/***
 * Mocked Data
 */
const data = {"error":false,"error_message":"","parse_tree":{"id":"gnc(0,231)","label":"gnc","children":[{"id":"function(1,45)","label":"function","children":[{"id":"data_type(1,5)","label":"data_type","children":[{"id":"int(1,4)","label":"int","children":[]}]},{"id":"identifier(5,9)","label":"identifier","children":[]},{"id":"function_parameter_list(9,23)","label":"function_parameter_list","children":[{"id":"function_parameter(10,15)","label":"function_parameter","children":[{"id":"data_type(10,14)","label":"data_type","children":[{"id":"int(10,13)","label":"int","children":[]}]},{"id":"identifier(14,15)","label":"identifier","children":[]}]},{"id":"function_parameter(17,22)","label":"function_parameter","children":[{"id":"data_type(17,21)","label":"data_type","children":[{"id":"int(17,20)","label":"int","children":[]}]},{"id":"identifier(21,22)","label":"identifier","children":[]}]}]},{"id":"statement(30,43)","label":"statement","children":[{"id":"return_statement(30,42)","label":"return_statement","children":[{"id":"expression(37,42)","label":"expression","children":[{"id":"logical_or_expression(37,42)","label":"logical_or_expression","children":[{"id":"logical_and_expression(37,42)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(37,42)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(37,42)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(37,42)","label":"bitwise_and_expression","children":[{"id":"equality_expression(37,42)","label":"equality_expression","children":[{"id":"comparison_expression(37,42)","label":"comparison_expression","children":[{"id":"shift_expression(37,42)","label":"shift_expression","children":[{"id":"additive_expression(37,42)","label":"additive_expression","children":[{"id":"multiplicative_expression(37,39)","label":"multiplicative_expression","children":[{"id":"cast_expression(37,38)","label":"cast_expression","children":[{"id":"unary_expression(37,38)","label":"unary_expression","children":[{"id":"identifier(37,38)","label":"identifier","children":[]}]}]}]},{"id":"op_add(39,40)","label":"op_add","children":[]},{"id":"multiplicative_expression(41,42)","label":"multiplicative_expression","children":[{"id":"cast_expression(41,42)","label":"cast_expression","children":[{"id":"unary_expression(41,42)","label":"unary_expression","children":[{"id":"identifier(41,42)","label":"identifier","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"function(48,100)","label":"function","children":[{"id":"data_type(48,52)","label":"data_type","children":[{"id":"int(48,51)","label":"int","children":[]}]},{"id":"identifier(52,56)","label":"identifier","children":[]},{"id":"function_parameter_list(56,58)","label":"function_parameter_list","children":[]},{"id":"statement(65,84)","label":"statement","children":[{"id":"declaration_statement(65,83)","label":"declaration_statement","children":[{"id":"data_type(65,69)","label":"data_type","children":[{"id":"int(65,68)","label":"int","children":[]}]},{"id":"identifier(69,70)","label":"identifier","children":[]},{"id":"expression(73,83)","label":"expression","children":[{"id":"logical_or_expression(73,83)","label":"logical_or_expression","children":[{"id":"logical_and_expression(73,83)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(73,83)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(73,83)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(73,83)","label":"bitwise_and_expression","children":[{"id":"equality_expression(73,83)","label":"equality_expression","children":[{"id":"comparison_expression(73,83)","label":"comparison_expression","children":[{"id":"shift_expression(73,83)","label":"shift_expression","children":[{"id":"additive_expression(73,83)","label":"additive_expression","children":[{"id":"multiplicative_expression(73,83)","label":"multiplicative_expression","children":[{"id":"cast_expression(73,83)","label":"cast_expression","children":[{"id":"unary_expression(73,83)","label":"unary_expression","children":[{"id":"function_call(73,83)","label":"function_call","children":[{"id":"identifier(73,77)","label":"identifier","children":[]},{"id":"expression(78,79)","label":"expression","children":[{"id":"logical_or_expression(78,79)","label":"logical_or_expression","children":[{"id":"logical_and_expression(78,79)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(78,79)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(78,79)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(78,79)","label":"bitwise_and_expression","children":[{"id":"equality_expression(78,79)","label":"equality_expression","children":[{"id":"comparison_expression(78,79)","label":"comparison_expression","children":[{"id":"shift_expression(78,79)","label":"shift_expression","children":[{"id":"additive_expression(78,79)","label":"additive_expression","children":[{"id":"multiplicative_expression(78,79)","label":"multiplicative_expression","children":[{"id":"cast_expression(78,79)","label":"cast_expression","children":[{"id":"unary_expression(78,79)","label":"unary_expression","children":[{"id":"int_literal(78,79)","label":"int_literal","children":[{"id":"dec_literal(78,79)","label":"dec_literal","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"expression(81,82)","label":"expression","children":[{"id":"logical_or_expression(81,82)","label":"logical_or_expression","children":[{"id":"logical_and_expression(81,82)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(81,82)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(81,82)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(81,82)","label":"bitwise_and_expression","children":[{"id":"equality_expression(81,82)","label":"equality_expression","children":[{"id":"comparison_expression(81,82)","label":"comparison_expression","children":[{"id":"shift_expression(81,82)","label":"shift_expression","children":[{"id":"additive_expression(81,82)","label":"additive_expression","children":[{"id":"multiplicative_expression(81,82)","label":"multiplicative_expression","children":[{"id":"cast_expression(81,82)","label":"cast_expression","children":[{"id":"unary_expression(81,82)","label":"unary_expression","children":[{"id":"int_literal(81,82)","label":"int_literal","children":[{"id":"dec_literal(81,82)","label":"dec_literal","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"statement(89,98)","label":"statement","children":[{"id":"return_statement(89,97)","label":"return_statement","children":[{"id":"expression(96,97)","label":"expression","children":[{"id":"logical_or_expression(96,97)","label":"logical_or_expression","children":[{"id":"logical_and_expression(96,97)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(96,97)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(96,97)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(96,97)","label":"bitwise_and_expression","children":[{"id":"equality_expression(96,97)","label":"equality_expression","children":[{"id":"comparison_expression(96,97)","label":"comparison_expression","children":[{"id":"shift_expression(96,97)","label":"shift_expression","children":[{"id":"additive_expression(96,97)","label":"additive_expression","children":[{"id":"multiplicative_expression(96,97)","label":"multiplicative_expression","children":[{"id":"cast_expression(96,97)","label":"cast_expression","children":[{"id":"unary_expression(96,97)","label":"unary_expression","children":[{"id":"identifier(96,97)","label":"identifier","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"function(103,229)","label":"function","children":[{"id":"data_type(103,107)","label":"data_type","children":[{"id":"int(103,106)","label":"int","children":[]}]},{"id":"identifier(107,110)","label":"identifier","children":[]},{"id":"function_parameter_list(110,131)","label":"function_parameter_list","children":[{"id":"function_parameter(111,116)","label":"function_parameter","children":[{"id":"data_type(111,115)","label":"data_type","children":[{"id":"int(111,114)","label":"int","children":[]}]},{"id":"identifier(115,116)","label":"identifier","children":[]}]},{"id":"function_parameter(118,123)","label":"function_parameter","children":[{"id":"data_type(118,122)","label":"data_type","children":[{"id":"int(118,121)","label":"int","children":[]}]},{"id":"identifier(122,123)","label":"identifier","children":[]}]},{"id":"function_parameter(125,130)","label":"function_parameter","children":[{"id":"data_type(125,129)","label":"data_type","children":[{"id":"int(125,128)","label":"int","children":[]}]},{"id":"identifier(129,130)","label":"identifier","children":[]}]}]},{"id":"statement(138,150)","label":"statement","children":[{"id":"declaration_statement(138,149)","label":"declaration_statement","children":[{"id":"data_type(138,142)","label":"data_type","children":[{"id":"int(138,141)","label":"int","children":[]}]},{"id":"identifier(142,145)","label":"identifier","children":[]},{"id":"expression(148,149)","label":"expression","children":[{"id":"logical_or_expression(148,149)","label":"logical_or_expression","children":[{"id":"logical_and_expression(148,149)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(148,149)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(148,149)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(148,149)","label":"bitwise_and_expression","children":[{"id":"equality_expression(148,149)","label":"equality_expression","children":[{"id":"comparison_expression(148,149)","label":"comparison_expression","children":[{"id":"shift_expression(148,149)","label":"shift_expression","children":[{"id":"additive_expression(148,149)","label":"additive_expression","children":[{"id":"multiplicative_expression(148,149)","label":"multiplicative_expression","children":[{"id":"cast_expression(148,149)","label":"cast_expression","children":[{"id":"unary_expression(148,149)","label":"unary_expression","children":[{"id":"int_literal(148,149)","label":"int_literal","children":[{"id":"dec_literal(148,149)","label":"dec_literal","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"statement(155,211)","label":"statement","children":[{"id":"while_statement(155,211)","label":"while_statement","children":[{"id":"expression(162,167)","label":"expression","children":[{"id":"logical_or_expression(162,167)","label":"logical_or_expression","children":[{"id":"logical_and_expression(162,167)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(162,167)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(162,167)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(162,167)","label":"bitwise_and_expression","children":[{"id":"equality_expression(162,167)","label":"equality_expression","children":[{"id":"comparison_expression(162,167)","label":"comparison_expression","children":[{"id":"shift_expression(162,164)","label":"shift_expression","children":[{"id":"additive_expression(162,164)","label":"additive_expression","children":[{"id":"multiplicative_expression(162,164)","label":"multiplicative_expression","children":[{"id":"cast_expression(162,163)","label":"cast_expression","children":[{"id":"unary_expression(162,163)","label":"unary_expression","children":[{"id":"identifier(162,163)","label":"identifier","children":[]}]}]}]}]}]},{"id":"op_lt(164,165)","label":"op_lt","children":[]},{"id":"shift_expression(166,167)","label":"shift_expression","children":[{"id":"additive_expression(166,167)","label":"additive_expression","children":[{"id":"multiplicative_expression(166,167)","label":"multiplicative_expression","children":[{"id":"cast_expression(166,167)","label":"cast_expression","children":[{"id":"unary_expression(166,167)","label":"unary_expression","children":[{"id":"identifier(166,167)","label":"identifier","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"statement(169,211)","label":"statement","children":[{"id":"block_statement(169,211)","label":"block_statement","children":[{"id":"statement(179,189)","label":"statement","children":[{"id":"expression(179,188)","label":"expression","children":[{"id":"assignment_expression(179,188)","label":"assignment_expression","children":[{"id":"unary_expression(179,182)","label":"unary_expression","children":[{"id":"identifier(179,182)","label":"identifier","children":[]}]},{"id":"assign_shift_left(183,186)","label":"assign_shift_left","children":[]},{"id":"expression(187,188)","label":"expression","children":[{"id":"logical_or_expression(187,188)","label":"logical_or_expression","children":[{"id":"logical_and_expression(187,188)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(187,188)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(187,188)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(187,188)","label":"bitwise_and_expression","children":[{"id":"equality_expression(187,188)","label":"equality_expression","children":[{"id":"comparison_expression(187,188)","label":"comparison_expression","children":[{"id":"shift_expression(187,188)","label":"shift_expression","children":[{"id":"additive_expression(187,188)","label":"additive_expression","children":[{"id":"multiplicative_expression(187,188)","label":"multiplicative_expression","children":[{"id":"cast_expression(187,188)","label":"cast_expression","children":[{"id":"unary_expression(187,188)","label":"unary_expression","children":[{"id":"identifier(187,188)","label":"identifier","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"statement(198,205)","label":"statement","children":[{"id":"expression(198,204)","label":"expression","children":[{"id":"assignment_expression(198,204)","label":"assignment_expression","children":[{"id":"unary_expression(198,199)","label":"unary_expression","children":[{"id":"identifier(198,199)","label":"identifier","children":[]}]},{"id":"assign_add(200,202)","label":"assign_add","children":[]},{"id":"expression(203,204)","label":"expression","children":[{"id":"logical_or_expression(203,204)","label":"logical_or_expression","children":[{"id":"logical_and_expression(203,204)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(203,204)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(203,204)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(203,204)","label":"bitwise_and_expression","children":[{"id":"equality_expression(203,204)","label":"equality_expression","children":[{"id":"comparison_expression(203,204)","label":"comparison_expression","children":[{"id":"shift_expression(203,204)","label":"shift_expression","children":[{"id":"additive_expression(203,204)","label":"additive_expression","children":[{"id":"multiplicative_expression(203,204)","label":"multiplicative_expression","children":[{"id":"cast_expression(203,204)","label":"cast_expression","children":[{"id":"unary_expression(203,204)","label":"unary_expression","children":[{"id":"int_literal(203,204)","label":"int_literal","children":[{"id":"dec_literal(203,204)","label":"dec_literal","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"statement(216,227)","label":"statement","children":[{"id":"return_statement(216,226)","label":"return_statement","children":[{"id":"expression(223,226)","label":"expression","children":[{"id":"logical_or_expression(223,226)","label":"logical_or_expression","children":[{"id":"logical_and_expression(223,226)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(223,226)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(223,226)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(223,226)","label":"bitwise_and_expression","children":[{"id":"equality_expression(223,226)","label":"equality_expression","children":[{"id":"comparison_expression(223,226)","label":"comparison_expression","children":[{"id":"shift_expression(223,226)","label":"shift_expression","children":[{"id":"additive_expression(223,226)","label":"additive_expression","children":[{"id":"multiplicative_expression(223,226)","label":"multiplicative_expression","children":[{"id":"cast_expression(223,226)","label":"cast_expression","children":[{"id":"unary_expression(223,226)","label":"unary_expression","children":[{"id":"identifier(223,226)","label":"identifier","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"EOI(231,231)","label":"EOI","children":[]}]},"ast":[{"Function":["Int","_foo",[{"param_type":"Int","param_name":"a"},{"param_type":"Int","param_name":"b"}],[{"ReturnStatement":{"BinaryExpression":["Add",{"Identifier":"a"},{"Identifier":"b"}]}}]]},{"Function":["Int","main",[],[{"Declaration":["Int","a"]},{"Assignment":["Simple",{"Identifier":"a"},{"FunctionCall":["_foo",[{"IntLiteral":0},{"IntLiteral":0}]]}]},{"ReturnStatement":{"Identifier":"a"}}]]},{"Function":["Int","bar",[{"param_type":"Int","param_name":"a"},{"param_type":"Int","param_name":"b"},{"param_type":"Int","param_name":"c"}],[{"Declaration":["Int","rst"]},{"Assignment":["Simple",{"Identifier":"rst"},{"IntLiteral":0}]},{"WhileStatement":[false,{"BinaryExpression":["LessThan",{"Identifier":"a"},{"Identifier":"b"}]},{"BlockStatement":[{"Assignment":["ShiftLeft",{"Identifier":"rst"},{"Identifier":"c"}]},{"Assignment":["Addition",{"Identifier":"a"},{"IntLiteral":1}]}]}]},{"ReturnStatement":{"Identifier":"rst"}}]]}]}
const astData = data.ast

/***
 * HLVM - High Level Virtual Machine
 * @param ast AST to be interpreted
 * @param entryPoint entry function name
 * @param args arguments as AST, e.g. {"IntLiteral": 233}
 * @returns {type, value} result
 */
function evalAST(ast, entryPoint, args) {
    // the entering & leaving of scopes will be maintained by the visitor function
    let symbolTable = [{}]
    let callStack = []

    const findSymbol = (symbolName) => {
        // iterate from top of the stack to emulate scope's name hiding
        for (const scopeTable of symbolTable.slice().reverse()) {
            if (symbolName in scopeTable) {
                return scopeTable[symbolName] // return ref of the symbol
            }
        }
        throw Error(`Can not find symbol ${symbolName}`)
    }

    const castValue = (origData, destType) => {
        let res = {
            type: destType,
            value: origData.value
        }
        switch (destType) {
            case "Int":
            case "Char":
            case "Short":
            case "Long":
                res.value = Math.floor(origData.value)
                break
            case "Bool":
                if (origData.type === "Bool") {
                    res.value = origData.value
                } else {
                    res.value = origData.value !== 0
                }
                break
            case "Float":
            case "Double":
                res.value = origData.value
                break
            default:
                throw new Error(`Cast to ${destType} not implemented`)
        }
        return res
    }

    const visitNode = (astNode) => {
        let res = null
        for (const node of astNode) {
            // [Control Flow] if function has returned, stop execution
            if (callStack.length && callStack.slice(-1)[0].hasReturn) {
                return res
            }
            if (node === "BreakStatement" || node === "ContinueStatement") { // special statements
                switch (node) {
                    case "BreakStatement":
                        const loopStack = callStack.slice(-1)[0].loopStack
                        loopStack[loopStack.length - 1] = true
                        return res // [Control Flow] stop exec following blocks after break
                    case "ContinueStatement":
                        throw new Error(`${node} not implemented`)
                    default:
                        throw new Error('strange thing')
                }
            } else for (const x in node) { // Actually there's only one entry inside
                switch (x) {
                    // basics
                    case "Assignment":
                        const [assignOperation, leftValue, assignChildren] = node[x]
                        const variable = visitNode([leftValue]) // TODO implement real leftValue
                        res = castValue(visitNode([assignChildren]), variable.type)
                        switch (assignOperation) {
                            case "Simple":
                                variable.value = res.value
                                break
                            case "Addition":
                                variable.value += res.value
                                break
                            case "Subtraction":
                                variable.value -= res.value
                                break
                            case "Multiplication":
                                variable.value *= res.value
                                break
                            case "Division":
                                variable.value /= res.value
                                break
                            case "Modulus":
                                variable.value %= res.value
                                break
                            case "BitwiseAnd":
                                variable.value &= res.value
                                break
                            case "InclusiveOr":
                                variable.value |= res.value
                                break
                            case "ExclusiveOr":
                                variable.value ^= res.value
                                break
                            case "ShiftLeft":
                                variable.value <<= res.value
                                break
                            case "ShiftRight":
                                variable.value >>= res.value
                                break
                            default:
                                throw new Error(`${assignOperation} not implemented`)
                        }
                        res = variable
                        break
                    case "Identifier":
                        res = findSymbol(node[x])
                        break

                    // literals
                    case "IntLiteral":
                        res = {
                            type: "Int",
                            value: node[x]
                        }
                        break
                    case "BoolLiteral":
                        res = {
                            type: "Bool",
                            value: node[x]
                        }
                        break
                    case "FloatLiteral":
                        res = {
                            type: "Float",
                            value: node[x]
                        }
                        break

                    // declarations
                    case "Declaration":
                        const [type, name] = node[x]
                        symbolTable.slice(-1)[0][name] = {
                            type,
                            value: 0
                        }
                        break
                    case "GlobalDeclaration":
                        const [globalType, globalName, globalAssignment] = node[x]
                        symbolTable.slice(-1)[0][globalName] = {
                            type: globalType,
                            value: castValue(visitNode([globalAssignment]).value, globalType)
                        }
                        break

                    // Expressions
                    case "BinaryExpression":
                        const [binaryOperator, lhs, rhs] = node[x]
                        const leftRes = visitNode([lhs])
                        const rightRes = visitNode([rhs])
                        switch (binaryOperator) {
                            case "Add":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value + rightRes.value
                                }
                                break
                            case "Subtract":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value - rightRes.value
                                }
                                break
                            case "Multiply":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value * rightRes.value
                                }
                                break
                            case "Modulus":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value % rightRes.value
                                }
                                break
                            case "Divide":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value / rightRes.value
                                }
                                break
                            case "Equal":
                                res = {
                                    type: 'Bool',
                                    value: leftRes.value === rightRes.value
                                }
                                break
                            case "ShiftRight":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value >> rightRes.value
                                }
                                break
                            case "ShiftLeft":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value << rightRes.value
                                }
                                break
                            case "LessThan":
                                res = {
                                    type: 'Bool',
                                    value: leftRes.value < rightRes.value
                                }
                                break
                            case "GreaterThan":
                                res = {
                                    type: 'Bool',
                                    value: leftRes.value > rightRes.value
                                }
                                break
                            case "LessEqual":
                                res = {
                                    type: 'Bool',
                                    value: leftRes.value <= rightRes.value
                                }
                                break
                            case "GreaterEqual":
                                res = {
                                    type: 'Bool',
                                    value: leftRes.value >= rightRes.value
                                }
                                break
                            case "NotEqual":
                                res = {
                                    type: 'Bool',
                                    value: leftRes.value !== rightRes.value
                                }
                                break
                            case "BitwiseAnd":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value & rightRes.value
                                }
                                break
                            case "ExclusiveOr":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value ^ rightRes.value
                                }
                                break
                            case "InclusiveOr":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value | rightRes.value
                                }
                                break
                            case "LogicalAnd":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value && rightRes.value
                                }
                                break
                            case "LogicalOr":
                                res = {
                                    type: leftRes.type, // TODO handle cast
                                    value: leftRes.value || rightRes.value
                                }
                                break
                            case "FetchRHS":
                                throw new Error(`FetchRHS should not appear at frontend`)
                            default:
                                throw new Error(`${binaryOperator} not implemented`)
                        }
                        break
                    case "UnaryExpression":
                        const [unaryOperator, unaryExpression] = node[x]
                        res = visitNode([unaryExpression])
                        switch (unaryOperator) {
                            case "UnaryMinus":
                                res.value *= -1
                                break
                            case "BitwiseComplement":
                                res.value = ~res.value
                                break
                            case "LogicalNot":
                                res.value = !res.value
                                break
                            default:
                                throw new Error(`${unaryOperator} not implemented`)
                        }
                        break
                    case "CastExpression":
                        const [castType, castExpression] = node[x]
                        console.log(castType)
                        console.log(castExpression)
                        res = castValue(visitNode([castExpression]), castType)
                        // throw new Error(`${x} not implemented`)
                        break

                    // functions
                    case "Function":
                        const [retType, funcName, parameters, funcChildren] = node[x]
                        symbolTable.slice(-1)[0][funcName] = {
                            retType,
                            parameters,
                            funcBlock: funcChildren
                        }
                        break
                    case "ReturnStatement":
                        res = visitNode([node[x]])
                        callStack.slice(-1)[0].returnResult = res
                        callStack.slice(-1)[0].hasReturn = true
                        return res // [!] break current exec flow
                    case "FunctionCall":
                        const [funcCallName, funcArguments] = node[x]
                        const callee = findSymbol(funcCallName)
                        // put arguments into symbol table
                        symbolTable.push({})
                        callStack.push({
                            funcCallName,
                            funcArguments,
                            returnResult: null,
                            hasReturn: false,
                            loopStack: []
                        })
                        // eslint-disable-next-line array-callback-return
                        callee.parameters.map(function(parameter, i) {
                            const {param_type, param_name} = parameter
                            symbolTable.slice(-1)[0][param_name] = castValue(visitNode([funcArguments[i]]), param_type)
                        })
                        visitNode(callee.funcBlock)
                        res = castValue(callStack.slice(-1)[0].returnResult, callee.retType)
                        callStack.pop()
                        symbolTable.pop()
                        break

                    // flow controls & statements
                    case "ForStatement":
                        const [initClause, condition, iteration, forStatement] = node[x]
                        const forLoopStack = callStack.slice(-1)[0].loopStack
                        forLoopStack.push(false)
                        for (visitNode(initClause); !forLoopStack.slice(-1)[0] && visitNode([condition]).value; visitNode([iteration])) {
                            visitNode([forStatement])
                        }
                        forLoopStack.pop()
                        break
                    case "WhileStatement":
                        const whileLoopStack = callStack.slice(-1)[0].loopStack
                        const [isDoWhile, whileCondition, whileStatements] = node[x]
                        whileLoopStack.push(false)
                        if (isDoWhile) {
                            do {
                                visitNode([whileStatements])
                            } while (!whileLoopStack.slice(-1)[0] && visitNode([whileCondition]).value)
                        } else {
                            while (!whileLoopStack.slice(-1)[0] && visitNode([whileCondition]).value) {
                                visitNode([whileStatements])
                            }
                        }
                        whileLoopStack.pop()
                        break
                    case "IfStatement":
                        const [ifCondExpression, ifTrueStatement, elseStatement] = node[x]
                        const ifRes = visitNode([ifCondExpression])
                        if (ifRes.value) {
                            visitNode([ifTrueStatement])
                        } else {
                            visitNode([elseStatement])
                        }
                        break
                    case "InitClause": // InitClause is a special form of BlockStatement
                    case "Arguments": // FuncCallArguments is a special form of BlockStatements
                    case "BlockStatement":
                        visitNode(node[x])
                        break

                    // unhandled case
                    default:
                        console.log(x)
                        console.log(node[x])
                }
            }
        }
        return res
    }

    // scan global symbols
    visitNode(ast)

    // call entry function
    const funcCall = [{
        "FunctionCall": [
            entryPoint,
            args
        ]
    }]
    return visitNode(funcCall)
}

const res = evalAST(astData, 'main', [])
console.log(JSON.stringify(res, null, 2))