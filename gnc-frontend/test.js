/***
 * Mocked Data
 */
const data = {"error":false,"error_message":"","parse_tree":{"id":"gnc(0,178)","label":"gnc","children":[{"id":"function(0,50)","label":"function","children":[{"id":"data_type(0,3)","label":"data_type","children":[{"id":"int(0,3)","label":"int","children":[]}]},{"id":"identifier(4,13)","label":"identifier","children":[]},{"id":"function_parameter_list(13,15)","label":"function_parameter_list","children":[]},{"id":"statement(22,33)","label":"statement","children":[{"id":"declaration_statement(22,32)","label":"declaration_statement","children":[{"id":"data_type(22,25)","label":"data_type","children":[{"id":"int(22,25)","label":"int","children":[]}]},{"id":"identifier(26,27)","label":"identifier","children":[]},{"id":"expression(30,32)","label":"expression","children":[{"id":"logical_or_expression(30,32)","label":"logical_or_expression","children":[{"id":"logical_and_expression(30,32)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(30,32)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(30,32)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(30,32)","label":"bitwise_and_expression","children":[{"id":"equality_expression(30,32)","label":"equality_expression","children":[{"id":"comparison_expression(30,32)","label":"comparison_expression","children":[{"id":"shift_expression(30,32)","label":"shift_expression","children":[{"id":"additive_expression(30,32)","label":"additive_expression","children":[{"id":"multiplicative_expression(30,32)","label":"multiplicative_expression","children":[{"id":"cast_expression(30,32)","label":"cast_expression","children":[{"id":"unary_expression(30,32)","label":"unary_expression","children":[{"id":"op_arithmetic_not(30,31)","label":"op_arithmetic_not","children":[]},{"id":"cast_expression(31,32)","label":"cast_expression","children":[{"id":"unary_expression(31,32)","label":"unary_expression","children":[{"id":"int_literal(31,32)","label":"int_literal","children":[{"id":"dec_literal(31,32)","label":"dec_literal","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"statement(38,48)","label":"statement","children":[{"id":"return_statement(38,47)","label":"return_statement","children":[{"id":"expression(45,47)","label":"expression","children":[{"id":"logical_or_expression(45,47)","label":"logical_or_expression","children":[{"id":"logical_and_expression(45,47)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(45,47)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(45,47)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(45,47)","label":"bitwise_and_expression","children":[{"id":"equality_expression(45,47)","label":"equality_expression","children":[{"id":"comparison_expression(45,47)","label":"comparison_expression","children":[{"id":"shift_expression(45,47)","label":"shift_expression","children":[{"id":"additive_expression(45,47)","label":"additive_expression","children":[{"id":"multiplicative_expression(45,47)","label":"multiplicative_expression","children":[{"id":"cast_expression(45,47)","label":"cast_expression","children":[{"id":"unary_expression(45,47)","label":"unary_expression","children":[{"id":"op_arithmetic_not(45,46)","label":"op_arithmetic_not","children":[]},{"id":"cast_expression(46,47)","label":"cast_expression","children":[{"id":"unary_expression(46,47)","label":"unary_expression","children":[{"id":"identifier(46,47)","label":"identifier","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"function(52,101)","label":"function","children":[{"id":"data_type(52,55)","label":"data_type","children":[{"id":"int(52,55)","label":"int","children":[]}]},{"id":"identifier(56,65)","label":"identifier","children":[]},{"id":"function_parameter_list(65,67)","label":"function_parameter_list","children":[]},{"id":"statement(74,84)","label":"statement","children":[{"id":"declaration_statement(74,83)","label":"declaration_statement","children":[{"id":"data_type(74,77)","label":"data_type","children":[{"id":"int(74,77)","label":"int","children":[]}]},{"id":"identifier(78,79)","label":"identifier","children":[]},{"id":"expression(82,83)","label":"expression","children":[{"id":"logical_or_expression(82,83)","label":"logical_or_expression","children":[{"id":"logical_and_expression(82,83)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(82,83)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(82,83)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(82,83)","label":"bitwise_and_expression","children":[{"id":"equality_expression(82,83)","label":"equality_expression","children":[{"id":"comparison_expression(82,83)","label":"comparison_expression","children":[{"id":"shift_expression(82,83)","label":"shift_expression","children":[{"id":"additive_expression(82,83)","label":"additive_expression","children":[{"id":"multiplicative_expression(82,83)","label":"multiplicative_expression","children":[{"id":"cast_expression(82,83)","label":"cast_expression","children":[{"id":"unary_expression(82,83)","label":"unary_expression","children":[{"id":"int_literal(82,83)","label":"int_literal","children":[{"id":"dec_literal(82,83)","label":"dec_literal","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"statement(89,99)","label":"statement","children":[{"id":"return_statement(89,98)","label":"return_statement","children":[{"id":"expression(96,98)","label":"expression","children":[{"id":"logical_or_expression(96,98)","label":"logical_or_expression","children":[{"id":"logical_and_expression(96,98)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(96,98)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(96,98)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(96,98)","label":"bitwise_and_expression","children":[{"id":"equality_expression(96,98)","label":"equality_expression","children":[{"id":"comparison_expression(96,98)","label":"comparison_expression","children":[{"id":"shift_expression(96,98)","label":"shift_expression","children":[{"id":"additive_expression(96,98)","label":"additive_expression","children":[{"id":"multiplicative_expression(96,98)","label":"multiplicative_expression","children":[{"id":"cast_expression(96,98)","label":"cast_expression","children":[{"id":"unary_expression(96,98)","label":"unary_expression","children":[{"id":"op_bitwise_not(96,97)","label":"op_bitwise_not","children":[]},{"id":"cast_expression(97,98)","label":"cast_expression","children":[{"id":"unary_expression(97,98)","label":"unary_expression","children":[{"id":"identifier(97,98)","label":"identifier","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"function(103,177)","label":"function","children":[{"id":"data_type(103,106)","label":"data_type","children":[{"id":"int(103,106)","label":"int","children":[]}]},{"id":"identifier(107,123)","label":"identifier","children":[]},{"id":"function_parameter_list(123,125)","label":"function_parameter_list","children":[]},{"id":"statement(132,143)","label":"statement","children":[{"id":"declaration_statement(132,142)","label":"declaration_statement","children":[{"id":"data_type(132,135)","label":"data_type","children":[{"id":"int(132,135)","label":"int","children":[]}]},{"id":"identifier(136,137)","label":"identifier","children":[]},{"id":"expression(140,142)","label":"expression","children":[{"id":"logical_or_expression(140,142)","label":"logical_or_expression","children":[{"id":"logical_and_expression(140,142)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(140,142)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(140,142)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(140,142)","label":"bitwise_and_expression","children":[{"id":"equality_expression(140,142)","label":"equality_expression","children":[{"id":"comparison_expression(140,142)","label":"comparison_expression","children":[{"id":"shift_expression(140,142)","label":"shift_expression","children":[{"id":"additive_expression(140,142)","label":"additive_expression","children":[{"id":"multiplicative_expression(140,142)","label":"multiplicative_expression","children":[{"id":"cast_expression(140,142)","label":"cast_expression","children":[{"id":"unary_expression(140,142)","label":"unary_expression","children":[{"id":"op_logical_not(140,141)","label":"op_logical_not","children":[]},{"id":"cast_expression(141,142)","label":"cast_expression","children":[{"id":"unary_expression(141,142)","label":"unary_expression","children":[{"id":"int_literal(141,142)","label":"int_literal","children":[{"id":"dec_literal(141,142)","label":"dec_literal","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"statement(148,160)","label":"statement","children":[{"id":"declaration_statement(148,159)","label":"declaration_statement","children":[{"id":"data_type(148,151)","label":"data_type","children":[{"id":"int(148,151)","label":"int","children":[]}]},{"id":"identifier(152,153)","label":"identifier","children":[]},{"id":"expression(156,159)","label":"expression","children":[{"id":"logical_or_expression(156,159)","label":"logical_or_expression","children":[{"id":"logical_and_expression(156,159)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(156,159)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(156,159)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(156,159)","label":"bitwise_and_expression","children":[{"id":"equality_expression(156,159)","label":"equality_expression","children":[{"id":"comparison_expression(156,159)","label":"comparison_expression","children":[{"id":"shift_expression(156,159)","label":"shift_expression","children":[{"id":"additive_expression(156,159)","label":"additive_expression","children":[{"id":"multiplicative_expression(156,159)","label":"multiplicative_expression","children":[{"id":"cast_expression(156,159)","label":"cast_expression","children":[{"id":"unary_expression(156,159)","label":"unary_expression","children":[{"id":"op_logical_not(156,157)","label":"op_logical_not","children":[]},{"id":"cast_expression(157,159)","label":"cast_expression","children":[{"id":"unary_expression(157,159)","label":"unary_expression","children":[{"id":"int_literal(157,159)","label":"int_literal","children":[{"id":"dec_literal(157,159)","label":"dec_literal","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"statement(165,175)","label":"statement","children":[{"id":"return_statement(165,174)","label":"return_statement","children":[{"id":"expression(172,174)","label":"expression","children":[{"id":"logical_or_expression(172,174)","label":"logical_or_expression","children":[{"id":"logical_and_expression(172,174)","label":"logical_and_expression","children":[{"id":"inclusive_or_expression(172,174)","label":"inclusive_or_expression","children":[{"id":"exclusive_or_expression(172,174)","label":"exclusive_or_expression","children":[{"id":"bitwise_and_expression(172,174)","label":"bitwise_and_expression","children":[{"id":"equality_expression(172,174)","label":"equality_expression","children":[{"id":"comparison_expression(172,174)","label":"comparison_expression","children":[{"id":"shift_expression(172,174)","label":"shift_expression","children":[{"id":"additive_expression(172,174)","label":"additive_expression","children":[{"id":"multiplicative_expression(172,174)","label":"multiplicative_expression","children":[{"id":"cast_expression(172,174)","label":"cast_expression","children":[{"id":"unary_expression(172,174)","label":"unary_expression","children":[{"id":"op_logical_not(172,173)","label":"op_logical_not","children":[]},{"id":"cast_expression(173,174)","label":"cast_expression","children":[{"id":"unary_expression(173,174)","label":"unary_expression","children":[{"id":"identifier(173,174)","label":"identifier","children":[]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{"id":"EOI(178,178)","label":"EOI","children":[]}]},"ast":[{"Function":["Int","neg_unary",[],[{"Declaration":["Int","a"]},{"Assignment":["Simple","a",{"UnaryExpression":["UnaryMinus",{"IntLiteral":2}]}]},{"ReturnStatement":{"UnaryExpression":["UnaryMinus",{"Identifier":"a"}]}}]]},{"Function":["Int","not_unary",[],[{"Declaration":["Int","a"]},{"Assignment":["Simple","a",{"IntLiteral":1}]},{"ReturnStatement":{"UnaryExpression":["BitwiseComplement",{"Identifier":"a"}]}}]]},{"Function":["Int","complement_unary",[],[{"Declaration":["Int","b"]},{"Assignment":["Simple","b",{"UnaryExpression":["LogicalNot",{"IntLiteral":0}]}]},{"Declaration":["Int","a"]},{"Assignment":["Simple","a",{"UnaryExpression":["LogicalNot",{"IntLiteral":23}]}]},{"ReturnStatement":{"UnaryExpression":["LogicalNot",{"Identifier":"b"}]}}]]}]}
const astData = data.ast

/***
 * HLVM - High Level Virtual Machine
 * @param ast AST to be interpreted
 * @param entryPoint entry function name
 * @param args arguments as AST, e.g. {"IntLiteral": 233}
 * @returns {type, value} result
 */

function evalAST(ast, entryPoint, args) {
    // the entering & leaving of scopes will be maintained by the visitor function
    let symbolTable = [{}]

    const findSymbol = (symbolName) => {
        // iterate from top of the stack to emulate scope's name hiding
        for (const scopeTable of symbolTable.slice().reverse()) {
            if (symbolName in scopeTable) {
                return scopeTable[symbolName] // return ref of the symbol
            }
        }
        throw Error(`Can not find symbol ${symbolName}`)
    }

    const castValue = (origData, destType) => {
        let res = {
            type: destType,
            value: origData.value
        }
        switch (destType) {
            case "Int":
                res.value = Math.floor(origData.value)
                break
            default:
                throw new Error(`Cast to ${destType} not implemented`)
        }
        return res
    }

    const visitNode = (astNode) => {
        // console.log(symbolTable)
        let res = null
        for (const node of astNode) {
            if (node === "BreakStatement" || node === "ContinueStatement") { // special statements
                throw new Error(node)
            } else for (const x in node) { // Actually there's only one entry inside
                switch (x) {
                    // basics
                    case "Assignment":
                        const [assignOperation, leftValue, assignChildren] = node[x]
                        const variable = findSymbol(leftValue) // TODO implement real leftValue
                        res = castValue(visitNode([assignChildren]), variable.type)
                        switch (assignOperation) {
                            case "Simple":
                                variable.value = res.value
                                break
                            case "Addition":
                                variable.value += res.value
                                break
                            case "Subtraction":
                                variable.value -= res.value
                                break
                            case "Multiplication":
                                variable.value *= res.value
                                break
                            case "Division":
                                variable.value /= res.value
                                break
                            case "Modulus":
                                variable.value %= res.value
                                break
                            case "BitwiseAnd":
                                variable.value &= res.value
                                break
                            case "InclusiveOr":
                                variable.value |= res.value
                                break
                            case "ExclusiveOr":
                                variable.value ^= res.value
                                break
                            case "ShiftLeft":
                                variable.value <<= res.value
                                break
                            case "ShiftRight":
                                variable.value >>= res.value
                                break
                            default:
                                throw new Error(`${assignOperation} not implemented`)
                        }
                        res = variable
                        break
                    case "Identifier":
                        res = findSymbol(node[x])
                        break

                    // literals
                    case "IntLiteral":
                        res = {
                            type: "Int",
                            value: node[x]
                        }
                        break
                    case "BoolLiteral":
                        throw new Error(`${x} not implemented`)
                        break
                    case "FloatLiteral":
                        throw new Error(`${x} not implemented`)
                        break

                    // declarations
                    case "Declaration":
                        const [type, name] = node[x]
                        symbolTable.slice(-1)[0][name] = {
                            type,
                            value: 0
                        }
                        break
                    case "GlobalDeclaration":
                        const [globalType, globalName, globalAssignment] = node[x]
                        throw new Error(`${x} not implemented`)
                        break

                    // Expressions
                    case "BinaryExpression":
                        const [binaryOperator, lhs, rhs] = node[x]
                        throw new Error(`${x} not implemented`)
                        break
                    case "UnaryExpression":
                        const [unaryOperator, unaryExpression] = node[x]
                        res = visitNode([unaryExpression])
                        switch (unaryOperator) {
                            case "UnaryMinus":
                                res.value *= -1
                                break
                            case "BitwiseComplement":
                                res.value = ~res.value
                                break
                            case "LogicalNot":
                                res.value = !res.value
                                break
                            default:
                                throw new Error(`${unaryOperator} not implemented`)
                        }
                        break
                    case "CastExpression":
                        const [castType, castExpression] = node[x]
                        throw new Error(`${x} not implemented`)
                        break

                    // functions
                    case "Function":
                        const [retType, funcName, parameters, funcChildren] = node[x]
                        symbolTable.slice(-1)[0][funcName] = {
                            retType,
                            parameters,
                            funcBlock: funcChildren
                        }
                        break
                    case "ReturnStatement":
                        res = visitNode([node[x]])
                        break
                    case "FunctionCall":
                        const [funcCallName, funcArguments] = node[x]
                        const callee = findSymbol(funcCallName)
                        // put arguments into symbol table
                        symbolTable.push({})
                        // eslint-disable-next-line array-callback-return
                        callee.parameters.map(function(parameter, i) {
                            const {param_type, param_name} = parameter
                            symbolTable.slice(-1)[0][param_name] = castValue(visitNode([funcArguments[i]]), param_type)
                        })
                        res = castValue(visitNode(callee.funcBlock), callee.retType)
                        symbolTable.pop()
                        break

                    // flow controls & statements
                    case "ForStatement":
                        const [initClause, condition, iteration, forStatement] = node[x]
                        throw new Error(`${x} not implemented`)
                        break
                    case "WhileStatement":
                        const [isDoWhile, whileCondition, whileStatements] = node[x]
                        throw new Error(`${x} not implemented`)
                        break
                    case "IfStatement": // IfStatements is visualized as a list of BlockStatements
                    case "InitClause": // InitClause is a special form of BlockStatement
                    case "Arguments": // FuncCallArguments is a special form of BlockStatements
                    case "BlockStatement":
                        throw new Error(`${x} not implemented`)
                        break
                    case "BreakStatement":
                    case "ContinueStatement":
                        break

                    // unhandled case
                    default:
                        console.log(x)
                        console.log(node[x])
                }
            }
        }
        return res
    }

    // scan global symbols
    visitNode(ast)

    // call entry function
    const funcCall = [{
        "FunctionCall": [
            entryPoint,
            args
        ]
    }]
    return visitNode(funcCall)
}

const res = evalAST(astData, 'complement_unary', [])
console.log(JSON.stringify(res, null, 2))